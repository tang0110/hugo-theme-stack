+++
author = "Devin"
title = "C语言——关键字"
date = "2023-08-01"
description = "C语言专题之关键字篇"
categories = [
    "C语言"
]
tags = [
    "C语言","关键字篇"
]
+++
![](1.jpg)
## C语言——关键字

### goto

>无条件跳转

### volatile

>1. **禁止编译器优化**：编译器在编译过程中会对变量进行各种优化，包括缓存寄存器中的变量值，以提高程序执行速度。但是，在某些情况下，这种优化可能导致问题，特别是当变量的值由外部因素（例如硬件或其他线程）更改时。使用`volatile` 关键字可以告诉编译器不要进行这些优化，以确保变量的值在任何时刻都是最新的。
>2. **适用于多线程编程**：在多线程环境中，多个线程可能同时访问和修改同一个变量。在这种情况下，使用`volatile` 可以确保线程在读取和写入`volatile` 变量时不会进行缓存，从而避免数据不一致的问题。
>3. **适用于嵌入式系统和硬件寄存器**：在嵌入式系统编程中，经常需要访问硬件寄存器，这些寄存器的值可能会在任何时刻由硬件更改。使用`volatile` 可以确保编译器不会对这些寄存器的访问进行优化。
>4. **防止编译器删除无用的代码**：在某些情况下，变量的值可能不会被用于计算结果，但它们的值仍然对程序的行为产生影响。使用`volatile` 可以防止编译器删除这些看似无用的代码。

### union

>对于联合体所有的成员都共享一块内存，而结构体是所有变量内存的叠加，需要考虑字节对齐问题，对于联合体来说，只要你修改里面的成员的数据就会修改其他成员的数据，而结构体的成员数据是不影响的
>
>**判断大小端问题**
>
>* 大端字节序：高字节存放在低位地址，低字节存放在高地址
>* 小端字节序：低字节存放在低位，高字节存放在高位
>
>**计算占用空间大小问题**
>
>```c
>对于不同位的操作系统，个别数据类型数据大小不一样，
>Long 和unsigned long在32位中是4个字节
>在64位中是8个字节
>	计算的时候需要考虑字节对齐问题：
>1.	所占空间必须是成员变量中字节最大的整数倍
>2.	每个变量类型的偏移量必须是该变量类型的整数倍
>3.	对于联合体，由于所有变量都是共用一块内存，还需注意数组占用最大内存
>例如：
>Typedef union {double I;int k[5];char c;} DATE;
>在联合体中成员变量最大为double为8个字节，所以最终大小必须是8的整数倍；又因为联合体是共占内存空间，即int*5=20字节，所以最终为24个字节
>
>Typedef struct data {int cat;DATE cow; double dog;}too;
>求sizeof(too);
>解：在结构体里面联合体为24，联合体的最大类型为8字节，所以联合体的起始位置必须满足偏移量为8的倍数，计算如下：
>Cat：1-4,
>DATE cow 8+24
>Double dog 32+8=40
>//联合体的计算公式：
>//最终的大小得是结构体中的类型的最大长度的整数倍，并且能容下所有类型
>union date
>{
>     char a;
>     double b[3];
>     char c;
>};
>typedef union date DATE;
>
>/*
>结构体的计算：
>1.最终的大小得是结构体中的类型的最大长度的整数倍
>2.除了结构体中的联合体外，其他类型的偏移量必须是该类型的整数倍
>3.如果里面有联合体，该联合体的起始位置要满足该联合体的里面的最大长度类型的偏移量
>*/
>struct test
>{
>    char a;//1
>    DATE d;//8+24
>    char b;//33
>    char c; //34
>};//最终40
>typedef struct test TEST;
>int main()
>{
>    printf("%ld\n",sizeof(DATE));//24
>    printf("%ld\n",sizeof(TEST));//40
>    return 0;
>}
>
>```

### define & typedef

>\#define是C语言中定义的语法，是预处理指令，在预处理时进行简单而机械的字符串替换，不作正确性检查，只有在编译已被展开的源程序时才会发现可能的错误并报错。
>
>typedef是关键字，在编译时处理，有类型检查功能。它在自己的作用域内给一个已经存在的类型一个别名，但不能在一个函数定义里面使用typedef。用typedef定义数组、指针、结构等类型会带来很大的方便，不仅使程序书写简单，也使意义明确，增强可读性。

### **extern**

>1. **变量声明**：通过使用 `extern`，你可以在一个源文件中声明一个在另一个源文件中定义的全局变量，以便在当前源文件中使用它，而不需要重新定义。这对于在多个文件中共享全局变量非常有用。
>
>   ```c
>   // File1.c
>   int globalVar; // 定义全局变量
>   // File2.c
>   extern int globalVar; // 声明在其他文件中定义的全局变量
>   ```
>
>2. **函数声明**：类似于变量，你也可以使用 `extern` 来声明在其他源文件中定义的函数。这允许你在当前文件中使用这些函数而无需重新定义它们。
>
>   ```c
>   // File1.c
>   void someFunction(); // 定义函数
>   // File2.c
>   extern void someFunction(); // 声明在其他文件中定义的函数
>   ```
>
>3. **解决多文件编程**：`extern` 用于多文件编程中，特别是当你将程序拆分成多个源文件时，有助于确保这些文件之间的全局变量和函数能够正确共享。它允许你在一个文件中定义，而在其他文件中声明和使用这些全局实体。
>
>4. **避免重复定义**：`extern` 声明允许你在一个文件中定义全局变量或函数，而在其他文件中声明，从而避免多次定义相同的变量或函数，这将导致链接错误。

### register

>1. **建议寄存器存储**：通过使用 `register` 关键字，程序员可以向编译器建议将某个变量存储在寄存器中。寄存器是位于中央处理单元（CPU）内部的存储区域，它的访问速度比内存要快得多。因此，将变量存储在寄存器中可以提高程序的执行速度。
>
>   ```c
>   register int counter; // 建议编译器将 counter 存储在寄存器中
>   ```
>
>2. **编译器决定**：需要强调的是，`register` 只是一个建议，而非强制要求。编译器可以选择是否将变量存储在寄存器中。通常，编译器会根据代码的复杂性和寄存器的可用性来决定是否采纳这些建议。
>
>3. **限制使用**：`register` 变量通常有一些限制，例如不能取地址或使用指针对其进行操作，因为寄存器变量不在内存中有地址。这也意味着 `register` 变量通常不能用于需要取地址的操作，如指针和数组的地址计算。
>
>4. **性能提升**：使用 `register` 可以提高程序的性能，特别是在循环中对频繁访问的变量使用 `register` 可能会产生显著的性能提升。

### **const**

>1. **创建常量变量**：通过将 `const` 关键字应用于变量，你可以创建一个不可更改的常量。这意味着一旦给定值赋予这个变量，它的值将不再改变。
>
>   ```c
>   const int max_value = 100;
>   ```
>
>2. **防止无意的修改**：使用 `const` 可以避免在代码中无意地修改常量的值。如果你尝试修改一个被声明为 `const` 的变量，编译器将生成错误或警告。
>
>   ```c
>   const double pi = 3.14159;
>   // 试图修改 pi 的值将导致编译错误
>   ```

### static 

>1. **文件作用域变量**：使用 `static` 可将全局变量的作用域限制在当前源文件中，防止其他文件访问或修改。
>
>   ```c
>   static int globalVar = 5; // 限制作用域在当前文件中
>   ```
>
>2. **静态局部变量**：在函数内部使用 `static` 可使局部变量在函数调用之间保持其值。
>
>   ```c
>   void myFunction() {
>       static int counter = 0; // 保持在函数调用之间的值
>       counter++;
>   }
>   ```
>
>3. **静态函数**：使用 `static` 可将函数的作用域限制在当前源文件中，避免与其他文件的函数冲突。
>
>   ```c
>   static void internalFunction() {
>       // 内部链接函数，只在当前文件中可见
>   }
>   ```
>
>4. **模块局变量**：通过将变量声明为 `static`，可以在不同的文件中创建具有持久性的变量，以避免冲突。
>
>   ```c
>   // File1.c
>   static int globalVar = 42; // 只能在当前文件中访问
>   
>   // File2.c
>   int anotherVar = 123; // 可以被其他文件访问的全局变量
>   ```
>
>**核心**
>
>* 限制作用域
>* 限制存储域

### sizeof & strlen()

>**区别**
>
>首先**sizeof是关键字，strlen是函数**，sizeof用来计算占用**内存大小**，strlen是用来计算**字符串的长度**，特别是对于需不需要包含\0问题：Sizeof是需要给\0计算空间的，strlen是不需要，sizeof是在编译的时候计算的，而strlen是在运行的时候计算
>
>**求指针大小**
>
>在32位机器下，对于sizeof(指针变量)都是4个字节，比如 Int *a;    Sizeof(a);
>
>**求引用大小**
>
>Sizeof(char &)   // 1 引用大小和数据类型有关
>
>**计算数组大小**
>
>```c
>int num[5]={1,2,3,4};
>printf("%ld\n",sizeof(num));//20
>
>char str[10]={"hello"};
>printf("%ld\n",strlen(str));//5
>printf("%ld\n",sizeof(str));//10
>
>```
>
>**不使用sizeof求数据类型字节的大小**
>
> ```c
> #define mysieof(value)  (char*)(&value+1)-(char*)(&value)
> ```
>
>**strlen(“\0”) = ? sizeof(“\0”)**
>
>```c
>printf("%d\n",sizeof("\0"));//2 因为这里有\0\0
>printf("%d\n",strlen("\0"));//0
>```
>
>**sizeof(a++)**
>
>```c
>int a = 2;
>printf("%d\n",sizeof(a++)); //4
>printf("%d\n",a);	// a = 2
>// 注意：对于sizeof只会求所占内存大小，不会进行表达式运算
>```
>
>**计算字符数组大小**
>
>```c
>char ch[]  = "hello";
>char str[10] = {'h','e','l','l','o'};
>printf("%d\n",sizeof(ch));//6
>printf("%d\n",strlen(ch));//5
>printf("%d\n",sizeof(str));//10
>printf("%d\n",strlen(str));//5
>```
>
>**char *str1 = “hello”和char str2[] = “hello”**
>
>```c
>char str[] = "hello";
>char *str1 ="hello";
>//区别一 数组名不可以自加,因为数组名是地址常量
>//str++;
>//str1++;
>//区别二 ,数组里面的元素可以修改，str1指向的地址的内容不可以修改 
>str[0] = 'W';
>*str1 = 'w';//段错误
>//总结： 数组名就相当于是指针常量，只可以修改里面的内容，不可以修改指向的地址，字符指针相当于是常量指针，不可以修改指向的地址的内容，可以修改地址
>```
>
>