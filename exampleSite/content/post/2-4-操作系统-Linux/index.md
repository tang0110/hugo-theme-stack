+++
author = "Devin"
title = "操作系统——Linux"
date = "2023-08-01"
description = "操作系统专题之Linux篇"
categories = [
    "操作系统"
]
tags = [
    "操作系统","Linux"
]
+++
![](1.jpg)

# Linux操作系统

## Linux 简介

>UNIX 是一个交互式系统，用于同时处理多进程和多用户同时在线。为什么要说 UNIX，那是因为 Linux 是由 UNIX 发展而来的，UNIX 是由程序员设计，它的主要服务对象也是程序员。Linux 继承了 UNIX 的设计目标。从智能手机到汽车，超级计算机和家用电器，从家用台式机到企业服务器，Linux 操作系统无处不在。



### Linux 接口

Linux 系统是一种金字塔模型的系统，如下所示

![](https://img-blog.csdnimg.cn/img_convert/96aca4a85ced2e23c519faa3b30a4937.png)

应用程序发起系统调用把参数放在寄存器中(有时候放在栈中)，并发出 trap 系统陷入指令切换用户态至内核态。因为不能直接在 C 中编写 trap 指令，因此 C 提供了一个库，库中的函数对应着系统调用。有些函数是使用汇编编写的，但是能够从 C 中调用。每个函数首先把参数放在合适的位置然后执行系统调用指令。因此如果你想要执行 read 系统调用的话，C 程序会调用 read 函数库来执行。这里顺便提一下，是由 POSIX 指定的库接口而不是系统调用接口。也就是说，POSIX 会告诉一个标准系统应该提供哪些库过程，它们的参数是什么，它们必须做什么以及它们必须返回什么结果。

除了操作系统和系统调用库外，Linux 操作系统还要提供一些标准程序，比如文本编辑器、编译器、文件操作工具等。直接和用户打交道的是上面这些应用程序。因此我们可以说 Linux 具有三种不同的接口：系统调用接口、库函数接口和应用程序接口

### Linux 组成部分

>1. 引导程序(Bootloader)：引导程序是管理计算机启动过程的软件，对于大多数用户而言，只是弹出一个屏幕，但其实内部操作系统做了很多事情
>2. 内核(Kernel)：内核是操作系统的核心，负责管理 CPU、内存和外围设备等。
>3. 初始化系统(Init System)：这是一个引导用户空间并负责控制守护程序的子系统。一旦从引导加载程序移交了初始引导，它就是用于管理引导过程的初始化系统。
>4. 后台进程(Daemon)：后台进程顾名思义就是在后台运行的程序，比如打印、声音、调度等，它们可以在引导过程中启动，也可以在登录桌面后启动
>5. 图形服务器(Graphical server)：这是在监视器上显示图形的子系统。通常将其称为 X 服务器或 X。
>6. 桌面环境(Desktop environment)：这是用户与之实际交互的部分，有很多桌面环境可供选择，每个桌面环境都包含内置应用程序，比如文件管理器、Web 浏览器、游戏等
>7. 应用程序(Applications)：桌面环境不提供完整的应用程序，就像 Windows 和 macOS 一样，Linux 提供了成千上万个可以轻松找到并安装的高质量软件。
>     Shell

### Linux 内核结构

在上面我们看到了 Linux 的整体结构，下面我们从整体的角度来看一下 Linux 的内核结构

![](https://img-blog.csdnimg.cn/img_convert/71ae901ed2d7fbfba6fbc4514d940769.png)

> **内核**直接坐落在硬件上，内核的主要作用就是 I/O 交互、内存管理和控制 CPU 访问。上图中还包括了 中断 和 调度器，中断是与设备交互的主要方式。中断出现时调度器就会发挥作用。这里的低级代码停止正在运行的进程，将其状态保存在内核进程结构中，并启动驱动程序。进程调度也会发生在内核完成一些操作并且启动用户进程的时候。
>
> **I/O 部分负责**与设备进行交互以及执行网络和存储 I/O 操作的所有内核部分。
> 从图中可以看出 I/O 层次的关系，最高层是一个虚拟文件系统(VFS)，也就是说不管文件是来自内存还是磁盘中，都是经过虚拟文件系统中的。从底层看，所有的驱动都是字符驱动或者块设备驱动。二者的主要区别就是是否允许随机访问。网络驱动设备并不是一种独立的驱动设备，它实际上是一种字符设备，不过网络设备的处理方式和字符设备不同。
>
> **网络软件**通常是模块化的，由不同的设备和协议来支持。大多数 Linux 系统在内核中包含一个完整的硬件路由器的功能，但是这个不能和外部路由器相比，路由器上面是协议栈，包括 TCP/IP 协议，协议栈上面是 socket 接口，socket 负责与外部进行通信，充当了门的作用。
>
> **磁盘驱动**上面是 I/O 调度器，它负责排序和分配磁盘读写操作，以尽可能减少磁头的无用移动。
>
> I/O 右边的是**内存部件**，程序被装载进内存，由 CPU 执行，这里会涉及到虚拟内存的部件，页面的换入和换出是如何进行的，坏页面的替换和经常使用的页面会进行缓存。
>
> **进程模块**负责进程的创建和终止、进程的调度、Linux 把进程和线程看作是可运行的实体，并使用统一的调度策略来进行调度。
>
> 在**内核最顶层**的是系统调用接口，所有的系统调用都是经过这里，系统调用会触发一个 trap，将系统从用户态转换为内核态，然后将控制权移交给上面的内核部件。

## Linux 进程和线程

### 基本概念

每个进程都会运行一段独立的程序，并且在初始化的时候拥有一个独立的控制线程。换句话说，每个进程都会有一个自己的程序计数器，这个程序计数器用来记录下一个需要被执行的指令。Linux 允许进程在运行时创建额外的线程。

![](https://img-blog.csdnimg.cn/img_convert/41747d306fef8c7b0113c58514fd1e60.png)

>Linux 是一个多道程序设计系统，因此系统中存在彼此相互独立的进程同时运行。此外，每个用户都会同时有几个活动的进程。因为如果是一个大型系统，可能有数百上千的进程在同时运行。
>
>在某些用户空间中，即使用户退出登录，仍然会有一些后台进程在运行，这些进程被称为 **守护进程**(daemon)。
>
>Linux 中有一种特殊的守护进程被称为 计划守护进程(Cron daemon) ，计划守护进程可以每分钟醒来一次检查是否有工作要做，做完会继续回到睡眠状态等待下一次唤醒。
>
>Cron 是一个守护程序，可以做任何你想做的事情，比如说你可以定期进行系统维护、定期进行系统备份等。

### Linux 进程创建

 fork 后，父进程和子进程相互独立。

虽然父进程和子进程保持相互独立，但是它们却能够共享相同的文件，如果在 fork 之前，父进程已经打开了某个文件，那么 fork 后，父进程和子进程仍然共享这个打开的文件。对共享文件的修改会对父进程和子进程同时可见。

那么该如何区分父进程和子进程呢？子进程只是父进程的拷贝，所以它们几乎所有的情况都一样，包括内存映像、变量、寄存器等。区分的关键在于 fork 函数调用后的返回值，如果 fork 后返回一个非零值，这个非零值即是子进程的 **进程标识符(Process Identiier, PID)**，而会给子进程返回一个零值，可以用下面代码来进行表示

```c
pid = fork();    // 调用 fork 函数创建进程
if(pid < 0){
  error()				 // pid < 0,创建失败
}
else if(pid > 0){
  parent_handle() // 父进程代码
}
else {
  child_handle()  // 子进程代码
}
```

父进程在 fork 后会得到子进程的 PID，这个 PID 即能代表这个子进程的唯一标识符也就是 PID。如果子进程想要知道自己的 PID，可以调用 getpid 方法。当子进程结束运行时，父进程会得到子进程的 PID，因为一个进程会 fork 很多子进程，子进程也会 fork 子进程，所以 PID 是非常重要的。我们把第一次调用 fork 后的进程称为 原始进程，一个原始进程可以生成一颗继承树

### Linux 进程间通信

Linux 进程间的通信机制通常被称为 Internel-Process communication,IPC 下面我们来说一说 Linux 进程间通信的机制，大致来说，Linux 进程间的通信机制可以分为 6 种

![](https://img-blog.csdnimg.cn/img_convert/603cf2d977b22c53f5b2790ab4c04dc3.png)

#### 信号 signal

信号是 UNIX 系统最先开始使用的进程间通信机制，因为 Linux 是继承于 UNIX 的，所以 Linux 也支持信号机制，通过向一个或多个进程发送异步事件信号来实现，信号可以从键盘或者访问不存在的位置等地方产生；信号通过 shell 将任务发送给子进程。

你可以在 Linux 系统上输入 kill -l 来列出系统使用的信号，下面是我提供的一些信号

![](https://img-blog.csdnimg.cn/img_convert/5862392401578d2116f8af90ad7d4aba.png)

进程可以选择忽略发送过来的信号，但是有两个是不能忽略的：SIGSTOP 和 SIGKILL 信号。SIGSTOP 信号会通知当前正在运行的进程执行关闭操作，SIGKILL 信号会通知当前进程应该被杀死。除此之外，进程可以选择它想要处理的信号，进程也可以选择阻止信号，如果不阻止，可以选择自行处理，也可以选择进行内核处理。如果选择交给内核进行处理，那么就执行默认处理。

#### 管道 pipe

Linux 系统中的进程可以通过建立管道 pipe 进行通信。

在两个进程之间，可以建立一个通道，一个进程向这个通道里写入字节流，另一个进程从这个管道中读取字节流。管道是同步的，当进程尝试从空管道读取数据时，该进程会被阻塞，直到有可用数据为止。

#### 共享内存

两个进程之间还可以通过共享内存进行进程间通信，其中两个或者多个进程可以访问公共内存空间。两个进程的共享工作是通过共享内存完成的，一个进程所作的修改可以对另一个进程可见(很像线程间的通信)。

![](https://img-blog.csdnimg.cn/img_convert/60d7a6344fd35ffc4be912210a9fc655.png)

在使用共享内存前，需要经过一系列的调用流程，流程如下

>1. 创建共享内存段或者使用已创建的共享内存段(shmget())
>2. 将进程附加到已经创建的内存段中(shmat())
>3. 从已连接的共享内存段分离进程(shmdt())
>4. 对共享内存段执行控制操作(shmctl())

#### 先入先出队列 FIFO

先入先出队列 FIFO 通常被称为 命名管道(Named Pipes)，命名管道的工作方式与常规管道非常相似，但是确实有一些明显的区别。未命名的管道没有备份文件：操作系统负责维护内存中的缓冲区，用来将字节从写入器传输到读取器。一旦写入或者输出终止的话，缓冲区将被回收，传输的数据会丢失。相比之下，命名管道具有支持文件和独特 API ，命名管道在文件系统中作为设备的专用文件存在。当所有的进程通信完成后，命名管道将保留在文件系统中以备后用。命名管道具有严格的 FIFO 行为

![](https://img-blog.csdnimg.cn/img_convert/b63b3178ac4828964d3c00d2b72e39d9.png)

写入的第一个字节是读取的第一个字节，写入的第二个字节是读取的第二个字节，依此类推。

#### 消息队列

> 消息队列是用来描述内核寻址空间内的内部链接列表。可以按几种不同的方式将消息按顺序发送到队列并从队列中检索消息。每个消息队列由 IPC 标识符唯一标识。消息队列有两种模式，一种是严格模式， 严格模式就像是 FIFO 先入先出队列似的，消息顺序发送，顺序读取。还有一种模式是 非严格模式，消息的顺序性不是非常重要。

#### 套接字 Socket

> 还有一种管理两个进程间通信的是使用 socket，socket 提供端到端的双相通信。一个套接字可以与一个或多个进程关联。就像管道有命令管道和未命名管道一样，套接字也有两种模式，套接字一般用于两个进程之间的网络通信，网络套接字需要来自诸如TCP（传输控制协议）或较低级别 UDP（用户数据报协议）等基础协议的支持。

套接字有以下几种分类

>**顺序包套接字**(Sequential Packet Socket)： 此类套接字为最大长度固定的数据报提供可靠的连接。此连接是双向的并且是顺序的。
>**数据报套接字**(Datagram Socket)：数据包套接字支持双向数据流。数据包套接字接受消息的顺序与发送者可能不同。
>**流式套接字**(Stream Socket)：流套接字的工作方式类似于电话对话，提供双向可靠的数据流。
>**原始套接字**(Raw Socket)： 可以使用原始套接字访问基础通信协议。

### Linux 进程管理系统调用

> 操作系统可以分为两种模式
>
> 内核态：操作系统内核使用的模式
> 用户态：用户应用程序所使用的模式
>
> 我们常说的 上下文切换 指的就是内核态模式和用户态模式的频繁切换。而 系统调用 指的就是引起内核态和用户态切换的一种方式，系统调用通常在后台静默运行，表示计算机程序向其操作系统内核请求服务。
>
> **fork** 调用用于创建一个与父进程相同的子进程，创建完进程后的子进程拥有和父进程一样的程序计数器、相同的 CPU 寄存器、相同的打开文件。
>
> **exec** 系统调用用于执行驻留在活动进程中的文件，调用 exec 后，新的可执行文件会替换先前的可执行文件并获得执行。也就是说，调用 exec 后，会将旧文件或程序替换为新文件或执行，然后执行文件或程序。新的执行程序被加载到相同的执行空间中，因此进程的 PID不会修改，因为我们**没有创建新进程，只是替换旧进程**。但是**进程的数据、代码、堆栈都已经被修改**。如果当前要被替换的进程包含多个线程，那么所有的线程将被终止，**新的进程映像被加载执行**。

#### 进程映像

什么是进程映像呢？进程映像是执行程序时所需要的可执行文件，通常会包括下面这些东西

![](https://img-blog.csdnimg.cn/img_convert/feb341dcf2c14b925b3d94b0b743fc99.png)

> 代码段（codesegment/textsegment）又称文本段，用来存放指令，运行代码的一块内存空间
>
> 数据段（datasegment）可读可写, 存储初始化的全局变量和初始化的 static 变量
>
> bss 段（bsssegment）：可读可写, 存储未初始化的全局变量和未初始化的 static 变量, bss 段中的数据一般默认为 0
>
> Data 段: 是可读写的，因为变量的值可以在运行时更改。此段的大小也固定。
>
> 栈（stack）：可读可写, 存储的是函数或代码中的局部变量(非 static 变量), 栈的生存期随代码块持续性，代码块运行就给你分配空间，代码块结束，就自动回收空间
>
> 堆（heap）：可读可写, 存储的是程序运行期间动态分配的 malloc/realloc 的空间, 堆的生存期随进程持续性，从 malloc/realloc 到 free 一直存在

### Linux 进程和线程的实现

#### Linux 进程

> 对于每个进程来说，在内存中都会有一个 **task_struct 进程描述符**与之对应。进程描述符包含了内核管理进程所有有用的信息，包括 调度参数、打开文件描述符等等。进程描述符从进程创建开始就一直存在于内核堆栈中。进程描述符是存在用户的任务结构中，当进程位于内存并开始运行时，进程描述符才会被调入内存。
>
> Linux 和 Unix 一样，都是通过 PID 来区分不同的进程，内核会将所有进程的任务结构组成为一个双向链表。PID 能够直接被映射称为进程的任务结构所在的地址，从而不需要遍历双向链表直接访问。

进程描述符可以归为下面这几类

>* 调度参数(scheduling parameters)：进程优先级、最近消耗 CPU 的时间、最近睡眠时间一起决定了下一个需要运行的进程
>* 内存映像(memory image)：我们上面说到，进程映像是执行程序时所需要的可执行文件，它由数据和代码组成。
>* 信号(signals)：显示哪些信号被捕获、哪些信号被执行
>* 寄存器：当发生内核陷入 (trap) 时，寄存器的内容会被保存下来。
>* 系统调用状态(system call state)：当前系统调用的信息，包括参数和结果
>* 文件描述符表(file descriptor table)：有关文件描述符的系统被调用时，文件描述符作为索引在文件描述符表中定位相关文件的 i-node 数据结构
>* 统计数据(accounting)：记录用户、进程占用系统 CPU 时间表的指针，一些操作系统还保存进程最多占用的 CPU 时间、进程拥有的最大堆栈空间、进程可以消耗的页面数等。
>* 内核堆栈(kernel stack)：进程的内核部分可以使用的固定堆栈
>* 其他： 当前进程状态、事件等待时间、距离警报的超时时间、PID、父进程的 PID 以及用户标识符等

创建新流程实际上非常简单。为子进程开辟一块新的用户空间的进程描述符，然后从父进程复制大量的内容。为这个子进程分配一个 PID，设置其内存映射，赋予它访问父进程文件的权限，注册并启动。

当执行 fork 系统调用时，调用进程会陷入内核并创建一些和任务相关的数据结构，比如内核堆栈(kernel stack) 和 thread_info 结构。

这个结构中包含进程描述符，进程描述符位于固定的位置，使得 Linux 系统只需要很小的开销就可以定位到一个运行中进程的数据结构。

进程描述符的主要内容是根据 父进程 的描述符来填充。Linux 操作系统会寻找一个可用的 PID，并且此 PID 没有被任何进程使用，更新进程标示符使其指向一个新的数据结构即可。为了减少 hash table 的碰撞，进程描述符会形成链表。它还将 task_struct 的字段设置为指向任务数组上相应的上一个/下一个进程。

从原则上来说，为子进程开辟内存区域并为子进程分配数据段、堆栈段，并且对父进程的内容进行复制，但是实际上 fork 完成后，子进程和父进程没有共享内存，所以需要复制技术来实现同步，但是复制开销比较大，因此 Linux 操作系统使用了一种 欺骗 方式。即为子进程分配页表，然后新分配的页表指向父进程的页面，同时这些页面是只读的。当进程向这些页面进行写入的时候，会开启保护错误。内核发现写入操作后，会为进程分配一个副本，使得写入时把数据复制到这个副本上，这个副本是共享的，这种方式称为 写入时复制(copy on write)，这种方式避免了在同一块内存区域维护两个副本的必要，节省内存空间。

在子进程开始运行后，操作系统会调用 exec 系统调用，内核会进行查找验证可执行文件，把参数和环境变量复制到内核，释放旧的地址空间。

现在新的地址空间需要被创建和填充。如果系统支持映射文件，就像 Unix 系统一样，那么新的页表就会创建，表明内存中没有任何页，除非所使用的页面是堆栈页，其地址空间由磁盘上的可执行文件支持。新进程开始运行时，立刻会收到一个缺页异常(page fault)，这会使具有代码的页面加载进入内存。最后，参数和环境变量被复制到新的堆栈中，重置信号，寄存器全部清零。新的命令开始运行。

下面是一个示例，用户输出 ls，shell 会调用 fork 函数复制一个新进程，shell 进程会调用 exec 函数用可执行文件 ls 的内容覆盖它的内存。

![](https://img-blog.csdnimg.cn/img_convert/65e4ac673fec32091abacb9b0865726c.png)

#### Linux 线程



> **用户级线程**避免使用内核，通常，每个线程会显示调用开关，发送信号或者执行某种切换操作来放弃 CPU，同样，计时器可以强制进行开关，用户线程的切换速度通常比内核线程快很多。在用户级别实现线程会有一个问题，即单个线程可能会垄断 CPU 时间片，导致其他线程无法执行从而 饿死。如果执行一个 I/O 操作，那么 I/O 会阻塞，其他线程也无法运行。

![](https://img-blog.csdnimg.cn/img_convert/f9fca746a766d870dc21caf9f8b41abd.png)

一种解决方案是，一些用户级的线程包解决了这个问题。可以使用时钟周期的监视器来控制第一时间时间片独占。然后，一些库通过特殊的包装来解决系统调用的 I/O 阻塞问题，或者可以为非阻塞 I/O 编写任务。

> **内核级线程**通常使用几个进程表在内核中实现，每个任务都会对应一个进程表。在这种情况下，内核会在每个进程的时间片内调度每个线程。

![](https://img-blog.csdnimg.cn/img_convert/452dbe93c8b96a83d8c89c2e804fe838.png)

所有能够阻塞的调用都会通过系统调用的方式来实现，当一个线程阻塞时，内核可以进行选择，是运行在同一个进程中的另一个线程（如果有就绪线程的话）还是运行一个另一个进程中的线程。



> **混合实现**, 结合用户空间和内核空间的优点，设计人员采用了一种 内核级线程 的方式，然后将用户级线程与某些或者全部内核线程多路复用起来

![](https://img-blog.csdnimg.cn/img_convert/23e06264cf263bc7de1df3b5931f1e45.png)

在这种模型中，编程人员可以自由控制用户线程和内核线程的数量，具有很大的灵活度。采用这种方法，内核只识别内核级线程，并对其进行调度。其中一些内核级线程会被多个用户级线程多路复用。

#### Linux 调度

> Linux 系统的调度算法，首先需要认识到，Linux 系统的线程是内核线程，所以 Linux 系统是基于线程的，而不是基于进程的。为了进行调度，Linux 系统将线程分为三类
>
> * 实时先入先出
> * 实时轮询
> * 分时
>
> **实时先入先出**线程具有最高优先级，它不会被其他线程所抢占，除非那是一个刚刚准备好的，拥有更高优先级的线程进入。**实时轮转线程**与实时先入先出线程基本相同，只是每个实时轮转线程都有一个时间量，时间到了之后就可以被抢占。如果多个实时线程准备完毕，那么每个线程运行它时间量所规定的时间，然后插入到实时轮转线程末尾。

**Linux O(1) 调度器**是历史上很流行的一个调度器。这个名字的由来是因为它能够在常数时间内执行任务调度。在 O(1) 调度器里，调度队列被组织成两个数组，一个是任务正在活动的数组，一个是任务过期失效的数组。如下图所示，每个数组都包含了 140 个链表头，每个链表头具有不同的优先级。

![](https://img-blog.csdnimg.cn/img_convert/65a01b213bbd75ebc1b99fdb1161fc54.png)

> **大致流程如下：**
>
> 调度器从正在活动数组中选择一个**优先级最高**的任务。如果这个任务的时间片过期失效了，就把它移动到过期失效数组中。如果这个任务阻塞了，比如说正在等待 I/O 事件，那么在它的时间片过期失效之前，一旦 I/O 操作完成，那么这个任务将会继续运行，它将被放回到之前正在活动的数组中，因为这个任务之前已经消耗一部分 CPU 时间片，所以它将运行剩下的时间片。当这个任务运行完它的时间片后，它就会被放到过期失效数组中。
>
> **一旦正在活动的任务数组中没有其他任务后**，调度器将会交换指针，使得正在活动的数组变为过期失效数组，过期失效数组变为正在活动的数组。使用这种方式可以保证每个优先级的任务都能够得到执行，不会导致线程饥饿。
>
> 在这种调度方式中，不同优先级的任务所得到 CPU 分配的时间片也是不同的，高优先级进程往往能得到较长的时间片，低优先级的任务得到较少的时间片。

**公平调度器(Completely Fair Scheduler, CFS)**。 CFS 的主要思想是使用一颗红黑树作为调度队列。CFS 会根据任务在 CPU 上的运行时间长短而将其有序地排列在树中，时间精确到纳秒级。下面是 CFS 的构造模型

![](https://img-blog.csdnimg.cn/img_convert/06156451881da5d8af09031d34e858c3.png)

>CFS 的调度过程如下：
>
>CFS 算法总是优先调度哪些使用 CPU 时间最少的任务。最小的任务一般都是在最左边的位置。当有一个新的任务需要运行时，CFS 会把这个任务和最左边的数值进行对比，如果此任务具有最小时间值，那么它将进行运行，否则它会进行比较，找到合适的位置进行插入。然后 CPU 运行红黑树上当前比较的最左边的任务。
>
>在红黑树中选择一个节点来运行的时间可以是常数时间，但是插入一个任务的时间是 O(loog(N))，其中 N 是系统中的任务数。考虑到当前系统的负载水平，这是可以接受的。
>
>调度器只需要考虑可运行的任务即可。这些任务被放在适当的调度队列中。不可运行的任务和正在等待的各种 I/O 操作或内核事件的任务被放入一个等待队列中。等待队列头包含一个指向任务链表的指针和一个自旋锁。自旋锁对于并发处理场景下用处很大。

#### Linux 启动

![](https://img-blog.csdnimg.cn/img_convert/e8776eaf794f3a8d9cd6953ae8136bcc.png)

>**整个系统启动过程如下**
>
>* 当计算机电源通电后，**BIOS**会进行开机自检(Power-On-Self-Test, POST)，**对硬件**进行检测和初始化。因为操作系统的启动会使用到磁盘、屏幕、键盘、鼠标等设备。下一步，磁盘中的第一个分区，也被称为 MBR(Master Boot Record) 主引导记录，被读入到一个固定的内存区域并执行。这个分区中有一个非常小的，只有 512 字节的程序。程序从磁盘中调入 **boot 独立程序**，boot 程序将自身复制到高位地址的内存从而为操作系统释放低位地址的内存。
>* 复制完成后，boot 程序**读取启动设备的根目录**。boot 程序要理解文件系统和目录格式。然后 boot 程序被**调入内核**，把控制权移交给内核。直到这里，boot 完成了它的工作。**系统内核开始运行**。
>* 内核启动代码是使用**汇编语言**完成的，主要包括创建内核堆栈、识别 CPU 类型、计算内存、禁用中断、启动内存管理单元等，然后调用 C 语言的 main 函数执行操作系统部分。这部分也会做很多事情，首先会分配一个消息缓冲区来存放调试出现的问题，调试信息会写入缓冲区。如果调试出现错误，这些信息可以通过诊断程序调出来。
>* 然后操作系统会进行**自动配置，检测设备，加载配置文件**，被检测设备如果做出响应，就会被添加到已链接的设备表中，如果没有相应，就归为未连接直接忽略。
>* 配置完所有硬件后，接下来要做的就是仔细手工**处理进程0**，设置其堆栈，然后运行它，执行初始化、配置时钟、挂载文件系统。**创建 init 进程(进程 1 ) 和 守护进程(进程 2)**。
>* init 进程会检测它的标志以确定它是否为**单用户还是多用户**服务。在前一种情况中，它会调用 fork 函数**创建一个 shell 进程**，并且等待这个进程结束。后一种情况调用 fork 函数创建一个运行系统初始化的 shell 脚本（即 /etc/rc）的进程，这个进程可以进行文件系统一致性检测、挂载文件系统、开启守护进程等。
>* 然后 **/etc/rc 这个进程会从 /etc/ttys 中读取数据**，/etc/ttys 列出了所有的终端和属性。对于每一个启用的终端，这个进程调用 fork 函数创建一个自身的副本，进行内部处理并运行一个名为 getty 的程序。
>* getty 程序会在终端上输入login:
>* 等待用户输入用户名，在输入用户名后，getty 程序结束，登陆程序 /bin/login 开始运行。login 程序需要输入密码，并与保存在 **/etc/passwd** 中的密码进行对比，如果输入正确，login 程序以用户 shell 程序替换自身，等待第一个命令。如果不正确，login 程序要求输入另一个用户名。

## Linux 内存管理

### 基本概念

每个 Linux 进程都会有地址空间，这些地址空间由三个段区域组成：text 段、data 段、stack 段。下面是进程地址空间的示例。

![](https://img-blog.csdnimg.cn/img_convert/5f573ece1ee76bf6a1a6dcd3f3cfc451.png)

>**数据段(data segment)** 包含了程序的变量、字符串、数组和其他数据的存储。数据段分为两部分，已经初始化的数据和尚未初始化的数据。其中 尚未初始化的数据 就是我们说的 BSS。数据段部分的初始化需要编译就期确定的常量以及程序启动就需要一个初始值的变量。所有 BSS 部分中的变量在加载后被初始化为 0 。
>
>和 代码段(Text segment) 不一样，data segment 数据段可以改变。程序总是修改它的变量。而且，许多程序需要在执行时动态分配空间。Linux 允许数据段随着内存的分配和回收从而增大或者减小。为了分配内存，程序可以增加数据段的大小。在 C 语言中有一套标准库 malloc 经常用于分配内存。进程地址空间描述符包含动态分配的内存区域称为 堆(heap)。
>
>第三部分段是 **栈段(stack segment)**。在大部分机器上，栈段会在虚拟内存地址顶部地址位置处，并向低位置处（向地址空间为 0 处）拓展。举个例子来说，在 32 位 x86 架构的机器上，栈开始于 0xC0000000，这是用户模式下进程允许可见的 3GB 虚拟地址限制。如果栈一直增大到超过栈段后，就会发生硬件故障并把页面下降一个页面。

当两个用户运行在相同程序中，例如编辑器(editor)，那么就会在内存中保持编辑器程序代码的两个副本，但是这种方式并不高效。Linux 系统支持共享文本段作为替代。下面图中我们会看到 A 和 B 两个进程，它们有着相同的文本区域。

![](https://img-blog.csdnimg.cn/img_convert/7b497dd65f81e9737264977860d00cfe.png)

数据段和栈段只有在 fork 之后才会共享，共享也是共享未修改过的页面。如果任何一个都需要变大但是没有相邻空间容纳的话，也不会有问题，因为相邻的虚拟页面不必映射到相邻的物理页面上。

除了**动态分配更多的内存**，Linux 中的进程可以通过 **内存映射文件** 来访问文件数据。这个特性可以使我们把一个文件映射到进程空间的一部分而该文件就可以像位于内存中的字节数组一样被读写。把一个文件映射进来使得随机读写比使用 read 和 write 之类的 I/O 系统调用要容易得多。共享库的访问就是使用了这种机制。如下所示

![](https://img-blog.csdnimg.cn/img_convert/19d609d72aef8c7258a7a72f5c29ee5d.png)

我们可以看到两个相同文件会被映射到相同的物理地址上，但是它们属于不同的地址空间。

映射文件的优点是，两个或多个进程可以同时映射到同一文件中，任意一个进程对文件的写操作对其他文件可见。通过使用映射临时文件的方式，可以为多线程共享内存 提供高带宽，临时文件在进程退出后消失。但是实际上，并没有两个相同的地址空间，因为每个进程维护的打开文件和信号不同。

### Linux 内存管理系统调用

事实上，POSIX 并没有给内存管理指定任何的系统调用。然而，Linux 却有自己的内存系统调用，主要系统调用如下

```c
s = brk(addr)	// 改变数据段大小
a = mmap(addr,len,prot,flags,fd,offset)	 // 进行映射
s = unmap(addr,len)	 // 取消映射
```

### Linux 内存管理实现

>**虚拟内存子系统**主要包括下面这些概念。
>
>* 大地址空间: 操作系统使系统使用起来好像比实际的物理内存要大很多，那是因为虚拟内存要比物理内存大很多倍。
>* 保护 : 系统中的每个进程都会有自己的虚拟地址空间。这些虚拟地址空间彼此完全分开，因此运行一个应用程序的进程不会影响另一个。并且，硬件虚拟内存机制允许内存保护关键内存区域。
>* 内存映射: 内存映射用来向进程地址空间映射图像和数据文件。在内存映射中，文件的内容直接映射到进程的虚拟空间中。
>* 公平的物理内存分配: 内存管理子系统允许系统中的每个正在运行的进程公平分配系统的物理内存。
>* 共享虚拟内存: 尽管虚拟内存让进程有自己的内存空间，但是有的时候你是需要共享内存的。例如几个进程同时在 shell 中运行，这会涉及到 IPC 的进程间通信问题，这个时候你需要的是共享内存来进行信息传递而不是通过拷贝每个进程的副本独立运行。

处理器在执行指令时，会从内存中读取指令并将其 解码(decode)，在指令解码时会获取某个位置的内容并将他存到内存中。然后处理器继续执行下一条指令。这样，**处理器总是在访问存储器以获取指令和存储数据**。

在虚拟内存系统中，所有的地址空间都是虚拟的而不是物理的。但是**实际存储和提取指令的是物理地址**，所以需要让处理器根据操作系统维护的一张表**将虚拟地址转换为物理地址**。

为了简单的完成转换，虚拟地址和物理地址会被分为固定大小的块，称为 页(page)。这些页有相同大小，如果页面大小不一样的话，那么操作系统将很难管理。Alpha AXP系统上的 Linux 使用 8 KB 页面，而 Intel x86 系统上的 Linux 使用 4 KB 页面。每个页面都有一个唯一的编号，即页面框架号（PFN）。

![](https://img-blog.csdnimg.cn/img_convert/039db658edb33c915ac4783c7e054c1c.png)

>上面就是 Linux 内存映射模型了，在这个页模型中，虚拟地址由两部分组成：**偏移量和虚拟页框号**。每次处理器遇到虚拟地址时都会提取偏移量和虚拟页框号。处理器必须将虚拟页框号转换为物理页号，然后以正确的偏移量的位置访问物理页。
>
>上图中展示了两个进程 A 和 B 的虚拟地址空间，每个进程都有自己的页表。这些页表将进程中的虚拟页映射到内存中的物理页中。页表中每一项均包含
>
>* 有效标志(valid flag)： 表明此页表条目是否有效
>* 该条目描述的物理页框号
>* 访问控制信息，页面使用方式，是否可写以及是否可以执行代码
>
>要将处理器的虚拟地址映射为内存的物理地址，首先需要计算虚拟地址的页框号和偏移量。页面大小为 2 的次幂，可以通过移位完成操作。
>
>**按需分页**
>
>由于物理内存要比虚拟内存少很多，因此操作系统需要注意尽量避免直接使用低效的物理内存。节省物理内存的一种方式是仅加载执行程序当前使用的页面（这何尝不是一种懒加载的思想呢？）。例如，可以运行数据库来查询数据库，在这种情况下，不是所有的数据都装入内存，只装载需要检查的数据。这种仅仅在需要时才将虚拟页面加载进内中的技术称为按需分页。
>
>**交换**
>
>如果某个进程需要将虚拟页面传入内存，但是此时没有可用的物理页面，那么操作系统必须丢弃物理内存中的另一个页面来为该页面腾出空间。
>
>如果页面已经修改过，那么操作系统必须保留该页面的内容，以便以后可以访问它。这种类型的页面被称为脏页，当将其从内存中移除时，它会保存在称为交换文件的特殊文件中。相对于处理器和物理内存的速度，对交换文件的访问非常慢，并且操作系统需要兼顾将页面写到磁盘的以及将它们保留在内存中以便再次使用。
>
>Linux 使用**最近最少使用(LRU)页面老化技术**来公平的选择可能会从系统中删除的页面，这个方案涉及系统中的每个页面，页面的年龄随着访问次数的变化而变化，如果某个页面访问次数多，那么该页就表示越 年轻，如果某个呃页面访问次数太少，那么该页越容易被 换出。
>
>**物理和虚拟寻址模式**
>
>大多数多功能处理器都支持 物理地址模式和虚拟地址模式的概念。物理寻址模式不需要页表，并且处理器不会在此模式下尝试执行任何地址转换。 Linux 内核被链接在物理地址空间中运行。
>
>**访问控制**
>
>页面表的每一项还包含访问控制信息，访问控制信息主要检查进程是否应该访问内存。
>
>必要时需要对内存进行访问限制。 例如包含可执行代码的内存，自然是只读内存； 操作系统不应允许进程通过其可执行代码写入数据。 相比之下，包含数据的页面可以被写入，但是尝试执行该内存的指令将失败。 大多数处理器至少具有两种执行模式：内核态和用户态。 你不希望访问用户执行内核代码或内核数据结构，除非处理器以内核模式运行。

### Linux缓存

>**缓冲区缓存**
>
>缓冲区高速缓存包含 块设备 驱动程序使用的数据缓冲区。**与字符设备相比，块设备通常需要较少的引脚**。缓冲区高速缓存通过设备标识符和块编号用于快速查找数据块。 如果可以在缓冲区高速缓存中找到数据，则无需从物理块设备中读取数据，这种访问方式要快得多。
>
>**页缓存**
>
>页缓存用于加快对磁盘上**图像和数据的访问**, 它用于一次一页地缓存文件中的内容，并且可以通过文件和文件中的偏移量进行访问。当页面从磁盘读入内存时，它们被缓存在页面缓存中。
>
>**交换区缓存**
>
>仅仅已修改（脏页）被保存在交换文件中, 只要这些页面在写入交换文件后没有修改，则下次交换该页面时，无需将其写入交换文件，因为该页面已在交换文件中。 可以直接丢弃。 在大量交换的系统中，这节省了许多不必要的和昂贵的磁盘操作。
>
>**硬件缓存**
>
>处理器中通常使用一种硬件缓存。页表条目的缓存。在这种情况下，处理器并不总是直接读取页表，而是根据需要缓存页的翻译。 这些是转换后备缓冲区 也被称为 TLB，包含来自系统中一个或多个进程的页表项的缓存副本。
>
>引用虚拟地址后，处理器将尝试查找匹配的 TLB 条目。 如果找到，则可以将虚拟地址直接转换为物理地址，并对数据执行正确的操作。 如果处理器找不到匹配的 TLB 条目， 它通过向操作系统发信号通知已发生 TLB 丢失获得操作系统的支持和帮助。系统特定的机制用于将该异常传递给可以修复问题的操作系统代码。 操作系统为地址映射生成一个新的 TLB 条目。 清除异常后，处理器将再次尝试转换虚拟地址。这次能够执行成功。
>
>使用缓存也存在缺点，为了节省精力，Linux 必须使用更多的时间和空间来维护这些缓存，并且如果缓存损坏，系统将会崩溃。

### Linux 页表

Linux 假定页表分为三个级别。访问的每个页表都包含下一级页表

![](https://img-blog.csdnimg.cn/img_convert/16c497037f3667951d15eec565c1a014.png)

图中的 PDG 表示全局页表，当创建一个新的进程时，都要为新进程创建一个新的页面目录，即 PGD。

**要将虚拟地址转换为物理地址，处理器必须获取每个级别字段的内容，将其转换为包含页表的物理页的偏移量，并读取下一级页表的页框号**。这样重复三次，直到找到包含虚拟地址的物理页面的页框号为止。

>**页分配和取消分配**
>对系统中物理页面有很多需求。例如，当图像加载到内存中时，操作系统需要分配页面。
>
>系统中所有物理页面均由 mem_map 数据结构描述，这个数据结构是 mem_map_t 的列表。它包括一些重要的属性
>
>* count ：这是页面的用户数计数，当页面在多个进程之间共享时，计数大于 1
>* age：这是描述页面的年龄，用于确定页面是否适合丢弃或交换
>* map_nr ：这是此mem_map_t描述的物理页框号。
>
>页面分配代码使用 free_area向量查找和释放页面，free_area 的每个元素都包含有关页面块的信息。
>
>**页面分配**
>
>Linux 的页面分配使用一种著名的伙伴算法来进行页面的分配和取消分配。页面以 2 的幂为单位进行块分配。这就意味着它可以分配 1页、2 页、4页等等，只要系统中有足够可用的页面来满足需求就可以。判断的标准是nr_free_pages> min_free_pages，如果满足，就会在 free_area 中搜索所需大小的页面块完成分配。free_area 的每个元素都有该大小的块的已分配页面和空闲页面块的映射。
>
>**分配算法**会搜索请求大小的页面块。如果没有任何请求大小的页面块可用的话，会搜寻一个是请求大小二倍的页面块，然后重复，直到**一直搜寻完 free_area 找到一个页面块为止**。如果找到的页面块要比请求的页面块大，就会对找到的页面块进行细分，直到找到合适的大小块为止。
>
>因为每个块都是 2 的次幂，所以拆分过程很容易，因为你只需将块分成两半即可。空闲块在适当的队列中排队，分配的页面块返回给调用者。
>
>![](https://img-blog.csdnimg.cn/img_convert/baf11cc75af1a5100677ccf92f95a437.png)
>
>如果请求一个 2 个页的块，则 4 页的第一个块（从第 4 页的框架开始）将被分成两个 2 页的块。第一个页面（从第 4 页的帧开始）将作为分配的页面返回给调用方，第二个块（从第 6 页的页面开始）将作为 2 页的空闲块排队到 free_area 数组的元素 1 上。
>
>**页面取消分配**
>
>上面的这种内存方式最造成一种后果，那就是**内存的碎片化**，会将较大的空闲页面分成较小的页面。页面解除分配代码会尽可能将页面重新组合成为更大的空闲块。每释放一个页面，都会检查相同大小的相邻的块，以查看是否空闲。如果是，则将其与新释放的页面块组合以形成下一个页面大小块的新的自由页面块。 每次将两个页面块重新组合为更大的空闲页面块时，页面释放代码就会尝试将该页面块重新组合为更大的空闲页面。 通过这种方式，可用页面的块将尽可能多地使用内存。
>
>例如上图，如果要释放第 1 页的页面，则将其与已经空闲的第 0 页页面框架组合在一起，并作为大小为 2页的空闲块排队到 free_area 的元素 1 中

### 内存映射

内核有两种类型的内存映射：**共享型（shared）和私有型(private)**。私有型是当进程为了只读文件，而不写文件时使用，这时，私有映射更加高效。 但是，任何对私有映射页的写操作都会导致内核停止映射该文件中的页。所以，写操作既不会改变磁盘上的文件，对访问该文件的其它进程也是不可见的。

**按需分页**
一旦可执行映像被内存映射到虚拟内存后，它就可以被执行了。因为只将映像的开头部分物理的拉入到内存中，因此它将很快访问物理内存尚未存在的虚拟内存区域。当进程访问没有有效页表的虚拟地址时，操作系统会报告这项错误。

页面错误描述页面出错的虚拟地址和引起的内存访问（RAM）类型。

Linux 必须找到代表发生页面错误的内存区域的 vm_area_struct 结构。由于搜索 vm_area_struct 数据结构对于有效处理页面错误至关重要，因此它们以 AVL（Adelson-Velskii和Landis）树结构链接在一起。如果引起故障的虚拟地址没有 vm_area_struct 结构，则此进程已经访问了非法地址，Linux 会向进程发出 SIGSEGV 信号，如果进程没有用于该信号的处理程序，那么进程将会终止。

然后，Linux 会针对此虚拟内存区域所允许的访问类型，检查发生的页面错误类型。 如果该进程以非法方式访问内存，例如写入仅允许读的区域，则还会发出内存访问错误信号。

现在，Linux 已确定页面错误是合法的，因此必须对其进行处理。

## 文件系统

### Linux 文件系统基本概念

Linux 中的文件是一个任意长度的**字节序列**，Linux 中的文件可以包含任意信息，比如 ASCII 码、二进制文件和其他类型的**文件是不加区分的**。

Linux 系统根目录下面的目录名

```c
/bin，  //它是重要的二进制应用程序，包含二进制文件，系统的所有用户使用的命令都在这里
/boot  //，启动包含引导加载程序的相关文件
/dev，  //包含设备文件，终端文件，USB 或者连接到系统的任何设备
/etc，  //配置文件，启动脚本等，包含所有程序所需要的配置文件，也包含了启动/停止单个应用程序的启动和关闭 shell 脚本
/home  //，本地主要路径，所有用户用 home 目录存储个人信息
/lib，  //系统库文件，包含支持位于 /bin 和 /sbin 下的二进制库文件
/lost  //+found，在根目录下提供一个遗失+查找系统，必须在 root 用户下才能查看当前目录下的内容
/medi  //a，挂载可移动介质
/mnt，  //挂载文件系统
/opt，  //提供一个可选的应用程序安装目录
/proc  //，特殊的动态目录，用于维护系统信息和状态，包括当前运行中进程信息
/root  //，root 用户的主要目录文件夹
/sbin  //，重要的二进制系统文件
/tmp，  // 系统和用户创建的临时文件，系统重启时，这个目录下的文件都会被删除
/usr，  //包含绝大多数用户都能访问的应用程序和文件
/var，  //经常变化的文件，诸如日志文件或数据库等
```

>Linux 文件系统的另外一个特性是支持 **加锁(locking)**。在一些应用中会出现两个或者更多的进程同时使用同一个文件的情况，这样很可能会导致竞争条件(race condition)。一种解决方法是对其进行加不同粒度的锁，就是为了防止某一个进程只修改某一行记录从而导致整个文件都不能使用的情况。
>
>POSIX 提供了一种灵活的、不同粒度级别的锁机制，允许一个进程使用一个不可分割的操作对一个字节或者整个文件进行加锁。加锁机制要求尝试加锁的进程指定其 要加锁的文件，开始位置以及要加锁的字节
>
>Linux 系统提供了两种锁：**共享锁和互斥锁**。**如果文件的一部分已经加上了共享锁，那么再加排他锁是不会成功的；如果文件系统的一部分已经被加了互斥锁，那么在互斥锁解除之前的任何加锁都不会成功。**为了成功加锁、请求加锁的部分的所有字节都必须是可用的。
>
>在加锁阶段，进程需要设计好加锁失败后的情况，也就是判断加锁失败后是否选择阻塞，如果选择阻塞式，那么当已经加锁的进程中的锁被删除时，这个进程会解除阻塞并替换锁。如果进程选择非阻塞式的，那么就不会替换这个锁，会立刻从系统调用中返回，标记状态码表示是否加锁成功，然后进程会选择下一个时间再次尝试。
>
>加锁区域是可以重叠的。

### Linux 文件系统调用

>当程序要求打开一个文件时，内核会进行如下操作
>
>* 授予访问权限
>* 在全局文件表(global file table)中创建一个条目(entry)
>* 向软件提供条目的位置
>
>文件描述符由唯一的非负整数组成，系统上每个打开的文件至少存在一个文件描述符。文件描述符最初在 Unix 中使用，并且被包括 , 当一个进程成功访问一个打开的文件时，内核会**返回一个文件描述符**，这个文件描述符指向全局文件表的 entry 项。这个文件表项包含文件的 inode 信息，字节位移，访问限制等。例如下图所示
>
>![](https://img-blog.csdnimg.cn/img_convert/730867f6f9cadbc67d1b457ff3bcba97.png)
>
>默认情况下，前三个文件描述符为 `STDIN(标准输入)`、`STDOUT(标准输出)`、`STDERR(标准错误)`。

在**文件系统调用**中，开销最大的就是 read 和 write 了。read 和 write 都有三个参数

* 文件描述符：告诉需要对哪一个打开文件进行读取和写入
* 缓冲区地址：告诉数据需要从哪里读取和写入哪里
* 统计：告诉需要传输多少字节

**对于每个文件**，Linux 都会跟踪文件模式（常规，目录，特殊文件），大小，最后修改时间以及其他信息。程序能够通过 stat 系统调用看到这些信息。第一个参数就是文件名，第二个是指向要放置请求信息结构的指针。这些结构的属性如下图所示。

* 存储文件的设备
* 存储文件的设备
* i-node 编号
* 文件模式(包括保护位信息)
* 文件链接的数量
* 文件所有者标识
* 文件所属的组
* 文件大小(字节)
* 创建时间
* 最后一个修改/访问时间

### Linux 文件系统的实现

>**虚拟文件系统(Virtual File System)**。 
>
>为了能够使应用程序能够在不同类型的本地或者远程设备上的文件系统进行交互，因为在 Linux 当中文件系统千奇百种，比较常见的有 EXT3、EXT4，还有基于内存的 ramfs、tmpfs 和基于网络的 nfs，和基于用户态的 fuse，当然 fuse 应该不能完全的文件系统，只能算是一个能把文件系统实现放到用户态的模块，满足了内核文件系统的接口，他们都是文件系统的一种实现。对于这些文件系统，Linux 做了一层抽象就是 VFS虚拟文件系统
>
>**VFS 支持的四个主要的文件系统结构**
>
>* 超级块	特定的文件系统, 包含了有关文件系统布局的重要信息，超级块如果遭到破坏那么就会导致整个文件系统不可读。
>* Dentry	目录项，路径的一个组成部分
>* I-node	特定的文件, i-node 索引节点，包含了每一个文件的描述符。
>* File	跟一个进程相关联的打开文件
>
>四个 VFS 对象中每个对象的操作数据结构的元素都是指向基础文件系统中功能的指针

#### Linux Ext2 文件系统

一个 ext2 Linux 磁盘分区包含了一个文件系统，这个文件系统的布局如下所示

![](https://img-blog.csdnimg.cn/img_convert/b8beac9b2b6bff9e597de3bcd55f4486.png)

>**Boot 块**也就是第 0 块不是让 Linux 使用的，而是用来加载和引导计算机启动代码的。在块 0 之后，磁盘分区被分成多个组，这些组与磁盘柱面边界所处的位置无关。
>
>第一个块是 **超级块(superblock)**。它包含有关文件系统布局的信息，包括 i-node、磁盘块数量和以及空闲磁盘块列表的开始。下一个是 **组描述符(group descriptor)**，其中包含有关位图的位置，组中空闲块和 i-node 的数量以及组中的目录数量的信息。图中的两个**位图**用来记录空闲块和空闲 i-node，这是从 MINIX 1文件系统继承的选择，大多数 UNIX 文件系统使用位图而不是空闲列表。每个位图的大小是一个块。如果一个块的大小是 1 KB，那么就限制了块组的数量是 8192 个块和 8192 个 i-node。块的大小是一个严格的限制，块组的数量不固定，在 4KB 的块中，块组的数量增大四倍。
>
>在超级块之后分布的是 **i-node** 它们自己，i-node 取值范围是 1 - 某些最大值。每个 i-node 是 128 字节的 long ，这些字节恰好能够描述一个文件。i-node 包含了统计信息(包含了 stat 系统调用能获得的所有者信息，实际上 stat 就是从 i-node 中读取信息的)，以及足够的信息来查找保存文件数据的所有磁盘块。
>
>在 i-node 之后的是 **数据块(data blocks)**。所有的文件和目录都保存在这。如果一个文件或者目录包含多个块，那么这些块在磁盘中的分布不一定是连续的，也有可能不连续。事实上，大文件块可能会被拆分成很多小块散布在整个磁盘上。



>为了**达到访问的目的**，需要首先使用 Linux 系统调用，例如 open，这个系统调用会确定打开文件的路径。路径分为两种，相对路径 和 绝对路径。如果使用相对路径，那么就会从当前目录开始查找，否则就会从根目录进行查找。
>
>目录文件的文件名最高不能超过 255 个字符，它的分配如下图所示![](https://img-blog.csdnimg.cn/img_convert/4a6d34a698e8b93c913616fe5c151d6a.png)每一个目录都由整数个磁盘块组成，这样目录就可以整体的写入磁盘。在一个目录中，文件和子目录的目录项都是未经排序的，并且一个挨着一个。目录项不能跨越磁盘块，所以通常在每个磁盘块的尾部会有部分未使用的字节。
>
>上图中每个目录项都由四个固定长度的属性和一个长度可变的属性组成。第一个属性是 i-node 节点数量，文件 first 的 i-node 编号是 19 ，文件 second 的编号是 42，目录 third 的 i-node 编号是 88。紧随其后的是 rec_len 域，表明目录项大小是多少字节，名称后面会有一些扩展，当名字以未知长度填充时，这个域被用来寻找下一个目录项，直至最后的未使用。这也是图中箭头的含义。紧随其后的是 类型域：F 表示的是文件，D 表示的是目录，最后是固定长度的文件名，上面的文件名的长度依次是 5、6、5，最后以文件名结束。
>
>rec_len 域是如何扩展的呢？如下图所示![](https://img-blog.csdnimg.cn/img_convert/f5f06111642f84f8afa783d155311b77.png)我们可以看到，中间的 second 被移除了，所以将其所在的域变为第一个目录项的填充。当然，这个填充可以作为后续的目录项。
>
>由于目录是按照线性的顺序进行查找的，因此可能需要很长时间才能在大文件末尾找到目录项。因此，系统会为近期的访问目录维护一个缓存。这个缓存用文件名来查找，如果缓存命中，那么就会避免线程搜索这样昂贵的开销。组成路径的每个部分都在目录缓存中保存一个 dentry 对象，并且通过 i-node 找到后续的路径元素的目录项，直到找到真正的文件 i - node。
>
>比如说要使用绝对路径来寻找一个文件，我们暂定这个路径是 **/usr/local/file**，那么需要经过如下几个**步骤**：
>
>首先，系统会确定根目录，它通常使用 2 号 i -node ，也就是索引 2 节点，因为索引节点 1 是 ext2 /3/4 文件系统上的坏块索引节点。系统会将一项放在 dentry 缓存中，以应对将来对根目录的查找。
>然后，在**根目录中查找字符串 usr**，**得到 /usr 目录的 i - node 节点号**。/usr 的 i - node 同样也进入 dentry 缓存。然后节点被取出，并从中解析出磁盘块，这样就可以读取 /usr 目录并查找字符串 local 了。一旦找到这个目录项，目录 /usr/local 的 i - node 节点就可以从中获得。有了 /usr/local 的 i - node 节点号，就可以读取 i - node 并确定目录所在的磁盘块。最后，从 /usr/local 目录查找 file 并确定其 i - node 节点呢号。
>如果文件存在，那么系统会提取 i - node 节点号并把它作为索引在 i - node 节点表中定位相应的 i - node 节点并装入内存。i - node 被存放在 i - node 节点表(i-node table) 中，节点表是一个内核数据结构，它会持有当前打开文件和目录的 i - node 节点号。下面是一些 Linux 文件系统支持的 i - node 数据结构。

>**文件读取过程，**还记得 read 函数是如何调用的吗？
>
>**n = read(fd,buffer,nbytes);**
>
>当内核接管后，它会从这三个参数以及内部表与用户有关的信息开始。内部表的其中一项是文件描述符数组。文件描述符数组用文件描述符 作为索引并为每一个打开文件保存一个表项。
>
>文件是和 i - node 节点号相关的。那么如何通过一个文件描述符找到文件对应的 i - node 节点呢？
>
>这里使用的一种设计思想是在文件描述符表和 i - node 节点表之间插入一个新的表，叫做 打开文件描述符(open-file-description table)。文件的读写位置会在打开文件描述符表中存在，如下图所示
>
>![](https://img-blog.csdnimg.cn/img_convert/11a3298a3bd2ab02533e90ce65378117.png)我们使用 shell 、P1 和 P2 来描述一下父进程、子进程、子进程的关系。Shell 首先生成 P1，P1 的数据结构就是 Shell 的一个副本，因此两者都指向相同的打开文件描述符的表项。当 P1 运行完成后，Shell 的文件描述符仍会指向 P1 文件位置的打开文件描述。然后 Shell 生成了 P2，新的子进程自动继承文件的读写位置，甚至 P2 和 Shell 都不知道文件具体的读写位置。
>
>上面描述的是父进程和子进程这两个 相关 进程，如果是一个不相关进程打开文件时，它将得到自己的打开文件描述符表项，以及自己的文件读写位置，这是我们需要的。
>
>因此，打开文件描述符相当于是给相关进程提供同一个读写位置，而给不相关进程提供各自私有的位置。
>
>i - node 包含三个间接块的磁盘地址，它们每个指向磁盘块的地址所能够存储的大小不一样。

#### Linux Ext4 文件系统

> 为了**防止由于系统崩溃和电源故障造成的数据丢失**，ext2 系统必须在每个数据块创建之后立即将其写入到磁盘上，磁盘磁头寻道操作导致的延迟是无法让人忍受的。为了增强文件系统的健壮性，Linux 依靠日志文件系统，ext3 是一个日志文件系统，它在 ext2 文件系统的基础之上做了改进，ext4 也是 ext3 的改进，**ext4 也是一个日志文件系统**。ext4 改变了 ext3 的块寻址方案，从而支持更大的文件和更大的文件系统大小。下面我们就来描述一下 ext4 文件系统的特性。
>
> 具有记录的文件系统最基本的功能就是记录日志，这个日志记录了按照顺序描述所有文件系统的操作。通过顺序写出文件系统数据或元数据的更改，操作不受磁盘访问期间磁盘头移动的开销。最终，这个变更会写入并提交到合适的磁盘位置上。如果这个变更在提交到磁盘前文件系统宕机了，那么在重启期间，系统会检测到文件系统未正确卸载，那么就会遍历日志并应用日志的记录来对文件系统进行更改。
>
> 日志是作为循环缓冲区管理的文件。日志可以存储在与主文件系统相同或者不同的设备上。日志记录的读写操作会由单独的 **JBD(Journaling Block Device)** 来扮演。
>
> JBD 中有三个主要的数据结构，分别是 log record(日志记录)、原子操作和事务。一个日志记录描述了一个低级别的文件系统操作，这个操作通常导致块内的变化。因为像是 write 这种系统调用会包含多个地方的改动 --- i - node 节点，现有的文件块，新的文件块和空闲列表等。相关的日志记录会以原子性的方式分组。ext4 会通知系统调用进程的开始和结束，以此使 JBD 能够确保原子操作的记录都能被应用，或者一个也不被应用。最后，主要从效率方面考虑，JBD 会视原子操作的集合为事务。一个事务中的日志记录是连续存储的。只有在所有的变更一起应用到磁盘后，日志记录才能够被丢弃。
>
> 由于为每个磁盘写出日志的开销会很大，所以 ext4 可以配置为保留所有磁盘更改的日志，或者仅仅保留与文件系统元数据相关的日志更改。仅仅记录元数据可以减少系统开销，提升性能，但不能保证不会损坏文件数据。其他的几个日志系统维护着一系列元数据操作的日志，例如 SGI 的 XFS。

#### NFS 网络文件系统

NFS 架构

> 每一个 NFS 服务都会导出一个或者多个目录供远程客户端访问。当一个目录可用时，它的所有子目录也可用。因此，通常整个目录树都会作为一个整体导出。服务器导出的目录列表会用一个文件来维护，这个文件是 /etc/exports，当服务器启动后，这些目录可以自动的被导出。客户端通过挂载这些导出的目录来访问它们。当一个客户端挂载了一个远程目录，这个目录就成为客户端目录层次的一部分，如下图所示。

NFS 实现

> 即使客户端和服务器的代码实现是独立于 NFS 协议的，大部分的 Linux 系统会使用一个下图的三层实现，顶层是系统调用层，系统调用层能够处理 open 、 read 、 close 这类的系统调用。在解析和参数检查结束后调用第二层，虚拟文件系统 (VFS) 层。

![](https://img-blog.csdnimg.cn/img_convert/fff191e4d40984928bb93b9da916b739.png)

VFS 层的任务是维护一个表，每个已经打开的文件都在表中有一个表项。VFS 层为每一个打开的文件维护着一个虚拟i节点，简称为 v - node。v 节点用来说明文件是本地文件还是远程文件。如果是远程文件的话，那么 v - node 会提供足够的信息使客户端能够访问它们。对于本地文件，会记录其所在的文件系统和文件的 i-node ，因为现代操作系统能够支持多文件系统。虽然 VFS 是为了支持 NFS 而设计的，但是现代操作系统都会使用 VFS，而不管有没有 NFS。

## Linux IO

#### Linux IO 基本概念

>Linux 中也有磁盘、打印机、网络等 I/O 设备，Linux 把这些设备当作一种 特殊文件 整合到文件系统中，一般通常位于 **/dev 目录**下。可以使用与普通文件相同的方式来对待这些特殊文件。
>
>特殊文件一般分为两种：
>
>**块特殊文件**是一个能存储固定大小块信息的设备，它支持以固定大小的块，扇区或群集读取和（可选）写入数据。**每个块都有自己的物理地址**。通常块的大小在 512 - 65536 之间。所有传输的信息都会以连续的块为单位。块设备的基本特征是每个块都较为对立，能够独立的进行读写。常见的块设备有 硬盘、蓝光光盘、USB 盘与字符设备相比，块设备通常需要较少的引脚。块特殊文件的缺点基于给定固态存储器的块设备比基于相同类型的存储器的字节寻址要慢一些，因为必须在块的开头开始读取或写入。所以，要读取该块的任何部分，**必须寻找到该块的开始**，读取整个块，如果不使用该块，则将其丢弃。要写入块的一部分，必须寻找到块的开始，**将整个块读入内存，修改数据，再次寻找到块的开头处，然后将整个块写回设备**。
>
>另一类 I/O 设备是**字符特殊文件**。字符设备以字符为单位发送或接收一个字符流，而不考虑任何块结构。字符设备是不可寻址的，也没有任何寻道操作。常见的字符设备有 打印机、网络设备、鼠标、以及大多数与磁盘不同的设备。
>
>每个设备特殊文件都会和 设备驱动 相关联。每个驱动程序都通过一个 主设备号 来标识。如果一个驱动支持多个设备的话，此时会在主设备的后面新加一个 次设备号 来标识。主设备号和次设备号共同确定了唯一的驱动设备。

#### 套接字(socket)

I/O 的另外一个概念是网络， 也是由 UNIX 引入，网络中一个很关键的概念就是 套接字(socket)。套接字允许用户连接到网络，正如邮筒允许用户连接到邮政系统，套接字的示意图如下

![](https://img-blog.csdnimg.cn/img_convert/e0719224dd9ea68c4dd48b7e7e2b14c2.png)

> 套接字的位置如上图所示，套接字可以动态创建和销毁。**成功创建一个套接字后，系统会返回一个文件描述符(file descriptor)**，在后面的创建链接、读数据、写数据、解除连接时都需要使用到这个文件描述符。每个套接字都支持一种特定类型的网络类型，在创建时指定。一般最常用的几种
>
> * 可靠的面向连接的字节流
> * 可靠的面向连接的数据包
> * 不可靠的数据包传输
>
> 一旦套接字在源计算机和目的计算机建立成功，那么两个计算机之间就可以建立一个链接。通信一方在本地套接字上使用 listen 系统调用，它就会创建一个缓冲区，然后阻塞直到数据到来。另一方使用 connect 系统调用，如果另一方接受 connect 系统调用后，则系统会在两个套接字之间建立连接。
>
> socket 连接建立成功后就像是一个管道，一个进程可以使用本地套接字的文件描述符从中读写数据，当连接不再需要的时候使用 close 系统调用来关闭。

#### Linux IO 实现

Linux 中的 IO 是通过一系列设备驱动实现的，每个设备类型对应一个设备驱动。设备驱动为操作系统和硬件分别预留接口，通过设备驱动来屏蔽操作系统和硬件的差异。

当用户访问一个特殊的文件时，由文件系统提供此特殊文件的主设备号和次设备号，并判断它是一个块特殊文件还是字符特殊文件。主设备号用于标识字符设备还是块设备，次设备号用于参数传递。

每个驱动程序 都有两部分：这两部分都是属于 Linux 内核，也都运行在内核态下。上半部分运行在调用者上下文并且与 Linux 其他部分交互。下半部分运行在内核上下文并且与设备进行交互。驱动程序可以调用内存分配、定时器管理、DMA 控制等内核过程。可被调用的内核功能都位于 驱动程序 - 内核接口 的文档中。

**块设备实现**

系统中处理块特殊文件 I/O 部分的目标是为了使传输次数尽可能的小。为了实现这个目标，Linux 系统在磁盘驱动程序和文件系统之间设置了一个 高速缓存(cache) ，如下图所示

![](https://img-blog.csdnimg.cn/img_convert/2eb17a875ef81c2484b7fc7f9e3dd9d5.png)

2.2 版本以后 Linux 内核只有一个统一的缓存一个 通用数据块层(generic block layer) 把这些融合在一起，实现了磁盘、数据块、缓冲区和数据页之间必要的转换。那么什么是通用数据块层？

>**通用数据块层**是一个内核的组成部分，用于处理对系统中所有块设备的请求。通用数据块主要有以下几个功能
>
>* 将数据缓冲区放在内存高位处，当 CPU 访问数据时，页面才会映射到内核线性地址中，并且此后取消映射实现 零拷贝机制，磁盘数据可以直接放入用户模式的地址空间，而无需先复制到内核内存中管理磁盘卷，会把不同块设备上的多个磁盘分区视为一个分区。
>* 利用最新的磁盘控制器的高级功能，例如 DMA 等。
>* cache 是提升性能的利器，不管以什么样的目的需要一个数据块，都会先从 cache 中查找，如果找到直接返回，避免一次磁盘访问，能够极大的提升系统性能。
>* 如果页面 cache 中没有这个块，操作系统就会把页面从磁盘中调入内存，然后读入 cache 进行缓存。
>
>cache 除了支持读操作外，也支持写操作，一个程序要写回一个块，首先把它写到 cache 中，而不是直接写入到磁盘中，等到磁盘中缓存达到一定数量值时再被写入到 cache 中。

**字符设备实现**

> 和字符设备的交互是比较简单的。由于字符设备会产生并使用字符流、字节数据，因此对随机访问的支持意义不大。一个例外是使用 行规则(line disciplines)。一个行规可以和终端设备相关联，使用 tty_struct 结构来表示，它表示与终端设备交换数据的解释器，当然这也属于内核的一部分。例如：行规可以对行进行编辑，映射回车为换行等一系列其他操作。

**网络设备实现**

网络设备的交互是不一样的，虽然 网络设备(network devices) 也会产生字符流，因为它们的异步(asynchronous) 特性是他们不易与其他字符设备在同一接口下集成。网络设备驱动程序会产生很多数据包，经由网络协议到达用户应用程序中。

## Linux 安全

> 一个 Linux 系统的用户群里由一系列注册用户组成，他们每一个都有一个唯一的 UID (User ID)。一个 UID 是一个位于 0 到 65535 之间的整数。文件（进程或者是其他资源）都标记了它的所有者的 UID。默认情况下，文件的所有者是创建文件的人，文件的所有者是创建文件的用户。
>
> 用户可以被分成许多组，每个组都会由一个 16 位的整数标记，这个组叫做 GID(组 ID)。给用户分组是手动完成的，它由系统管理员执行，分组就是在数据库中添加一条记录指明哪个用户属于哪个组。一个用户可以属于不同组。
>
> Linux 中的基本安全机制比较容易理解，**每个进程都会记录它所有者的 UID 和 GID**。当文件创建后，它会获取创建进程的 UID 和 GID。当一个文件被创建时，它的 UID 和 GID 就会被标记为进程的 UID 和 GID。这个文件同时会获取由该进程决定的一些权限。这些权限会指定所有者、所有者所在组的其他用户及其他用户对文件具有什么样的访问权限。对于这三类用户而言，潜在的访问权限是 读、写和执行，分别由 r、w 和 x 标记。当然，执行文件的权限仅当文件时可逆二进制程序时才有意义。试图执行一个拥有执行权限的非可执行文件，系统会报错。

**Linux 用户分为三种**

* root（超级管理员），它的 UID 为 0，这个用户有极大的权限，可以直接无视很多的限制 ，包括读写执行的权限。
* 系统用户，UID 为 1～499。
* 普通用户，UID 范围一般是 500～65534。这类用户的权限会受到基本权限的限制，也会受到来自管理员的限制。不过要注意 nobody 

